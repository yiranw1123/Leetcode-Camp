1049.最后一块石头的重量

    //因为要剩余石头的重量最小，相当于把总石头重量分成两份，让两份的差7最小
    //最好情况是当两堆重量相等时，剩余石头重量为0
    public int lastStoneWeightII(int[] stones) {
        int n = stones.length;
        int sum = 0;
        for(int i = 0;i<n;i++){
            sum += stones[i];
        }
        int target = sum/2;
        //使用物品0 ->i， 背包容量为j的情况下，背包中的最大价值
        int[][] dp = new int[n][target+1];

        for(int j = stones[0];j<=target;j++){
            dp[0][j] = stones[0];
        }
        //循环每个石头
        for(int i = 1;i<n;i++){
            //循环背包容量
            for(int j = 1;j<=target;j++){
                //当前石头大于背包容量，无法使用
                if(j < stones[i]){
                    dp[i][j] = dp[i-1][j];
                } else{
                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - stones[i]] + stones[i]);
                }
            }
        }
        return sum - 2 * dp[n-1][target];
    }

//滚动数组


    public int lastStoneWeightII(int[] stones) {
        int n = stones.length;
        int sum = 0;
        for(int i = 0;i<n;i++){
            sum += stones[i];
        }
        int target = sum/2;

        int[][] dp = new int[2][target+1];
        for(int i = 1;i <= n;i++){
            int w = stones[i-1];
            int a = i &1, b = (i-1) & 1;
            for (int j = 0;j<=target;j++){
                dp[a][j] = dp[b][j];
                if(j>=w) dp[a][j] = Math.max(dp[a][j], dp[b][j-w] + w);
            }
        }
        return Math.abs(sum - dp[n&1][target] - dp[n&1][target]);
    }
